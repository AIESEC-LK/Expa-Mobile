# Architecture Documentation

## System Architecture

### Overview

EXPA Mobile is a single-page application (SPA) built with React and Vite, designed as a Progressive Web Application (PWA) for mobile-first usage. The application follows a component-based architecture with clear separation of concerns.

## Application Layers

### 1. Presentation Layer

**Location**: `src/components/`, `src/pages/`

The presentation layer consists of React components organized by responsibility:

- **Pages**: Top-level route components (`ApplicationsOfOpportunitiesIManage`, `OGXPage`, `Home`, `LandingPage`)
- **Components**: Reusable UI components (`ApplicationCard`, `StatusDropdown`, `Navbar`, `Footer`)
- **Layout**: Main application layout wrapper (`Layout.jsx`)

**Pattern**: Functional components with React hooks for state management.

### 2. State Management Layer

**Location**: `src/AuthProvider.jsx`, component-level state

The application uses:
- **React Context API**: For global authentication state (`AuthProvider`)
- **Local Component State**: React hooks (`useState`, `useEffect`) for component-specific state
- **No Global State Management**: No Redux or Zustand - state is managed locally or through context

**State Flow**:
```
User Action → Component Handler → API Call → State Update → Re-render
```

### 3. API Layer

**Location**: `src/api/`

The API layer abstracts GraphQL communication:

```
Component → API Function → fetchGraphQL → GraphQL API
```

**Key Files**:
- `graphql.js`: Core GraphQL helper function
- `ApplicationIndexQuery_*.jsx`: Query definitions
- `ApplicationMutations.jsx`: Mutation definitions
- Other query/mutation files for specific operations

**Pattern**: Each API file exports functions that use the shared `fetchGraphQL` helper.

### 4. Authentication Layer

**Location**: `src/keycloak.js`, `src/AuthProvider.jsx`

**Flow**:
1. Keycloak initialization on app load
2. Token rehydration from localStorage
3. Silent SSO check
4. Token refresh management
5. Context provider for app-wide auth state

**Token Storage**:
- `keycloak_token`: Access token
- `keycloak_refresh_token`: Refresh token
- `aiesec_token`: Extracted AIESEC access token for API calls

### 5. Configuration Layer

**Location**: `src/config/`

Centralized configuration for:
- **Status Configuration**: Status definitions, styles, transitions (`statusConfig.jsx`)
- **PWA Configuration**: PWA settings and caching strategies (`pwaConfig.js`)
- **Application Defaults**: Default query variables and filters

### 6. Service Worker Layer

**Location**: Generated by Vite PWA plugin, registered in `src/pwaRegister.js`

**Responsibilities**:
- Asset precaching
- Runtime API caching
- Update management
- Offline support

## Data Flow

### Application List Flow

```
User Opens Page
    ↓
ApplicationsOfOpportunitiesIManage Component Mounts
    ↓
useEffect Triggers fetchData()
    ↓
fetchApplications() with filters/pagination
    ↓
fetchGraphQL() sends GraphQL query
    ↓
GraphQL API returns data
    ↓
State updated with applications
    ↓
Component re-renders with ApplicationCard components
```

### Status Change Flow

```
User Clicks Status Dropdown
    ↓
StatusDropdown Component
    ↓
User Selects New Status
    ↓
onChangeStatus Callback
    ↓
handleApplicationStatusChange() in parent
    ↓
changeStatusOfApplication() API call
    ↓
GraphQL Mutation Executed
    ↓
On Success: fetchData() to refresh list
    ↓
UI Updates with new status
```

### Authentication Flow

```
App Initializes (main.jsx)
    ↓
initKeycloak() called
    ↓
Check localStorage for existing tokens
    ↓
If tokens exist: Rehydrate and validate
    ↓
If no tokens: Silent SSO check
    ↓
Keycloak returns authentication status
    ↓
AuthProvider updates context
    ↓
Protected routes check authentication
    ↓
Render appropriate page or redirect
```

## Component Hierarchy

```
App
├── Router
    ├── Route "/" (LandingPage or Redirect)
    └── Route "/app" (Protected)
        └── Layout
            ├── Navbar
            ├── Outlet (Page Content)
            │   ├── Home
            ├── ApplicationsOfOpportunitiesIManage
            │   ├── Search Input
            │   ├── Status Filter
            │   ├── ApplicationCard[] (for each application)
            │   │   ├── StatusDropdown
            │   │   └── Rejection Modal (conditional)
            │   └── PaginationControls
            ├── OGXPage
            │   └── OGXApplicationCard[] (for each person)
            └── Footer
            └── PWAUpdatePrompt
```

## Routing Architecture

### Route Structure

```
/ → LandingPage (or redirect to /app if authenticated)
/app → Layout (Protected)
  ├── /app → Home
  ├── /app/icx/applications/my-opportunities → ApplicationsOfOpportunitiesIManage
  └── /app/ogx → OGXPage
```

### Route Protection

- **ProtectedRoute**: Requires authentication, redirects to `/` if not authenticated
- **AuthenticatedRoute**: Shows LandingPage if not authenticated, otherwise shows children

## API Architecture

### GraphQL Integration

**Query Pattern**:
```javascript
const QUERY = `query QueryName($variables: Type!) { ... }`
const data = await fetchGraphQL(QUERY, variables)
```

**Mutation Pattern**:
```javascript
const MUTATION = `mutation MutationName($id: ID!) { ... }`
const result = await fetchGraphQL(MUTATION, { id })
```

### Error Handling

- GraphQL errors are caught and logged
- User-friendly error messages displayed
- Network errors handled gracefully

### Caching Strategy

- **Service Worker**: Caches GraphQL responses with NetworkFirst strategy
- **Browser Cache**: Standard HTTP caching
- **No Client-Side Cache**: No Apollo Client or similar - fresh data on each request

## Styling Architecture

### Tailwind CSS

- **Utility-First**: All styling via Tailwind utility classes
- **Custom Colors**: Extended color palette in `tailwind.config.js` for status colors
- **Responsive**: Mobile-first breakpoints
- **No CSS Modules**: Global Tailwind classes

### Status Styling

Status colors defined in `tailwind.config.js`:
- Each status has `light` (background) and `DEFAULT` (text) colors
- Used via `bg-status-{status}-light text-status-{status}` classes

## PWA Architecture

### Service Worker Lifecycle

1. **Registration**: On app load, service worker registered
2. **Installation**: Assets precached
3. **Activation**: Service worker takes control
4. **Update Check**: Periodic checks for new versions
5. **Update Prompt**: User notified of available updates

### Caching Strategies

1. **Precache**: Static assets (JS, CSS, HTML, images)
2. **Runtime Cache**: 
   - GraphQL API: NetworkFirst (24h)
   - Auth API: NetworkFirst (1h)

### Offline Support

- Static assets available offline
- Cached API responses available offline
- New API requests fail gracefully when offline

## Build Architecture

### Vite Build Process

1. **Development**: 
   - Vite dev server with HMR
   - Fast refresh for React components
   - Source maps enabled

2. **Production**:
   - Code splitting
   - Minification
   - Tree shaking
   - PWA manifest and service worker generation

### Output Structure

```
dist/
├── index.html
├── assets/
│   ├── index-{hash}.js
│   └── index-{hash}.css
├── manifest.webmanifest
├── sw.js (service worker)
├── registerSW.js
└── static assets (images, etc.)
```

## Security Architecture

### Authentication Security

- Tokens stored in localStorage (consider httpOnly cookies for production)
- Token refresh before expiration
- Automatic logout on token expiration
- HTTPS required for Keycloak

### API Security

- Authorization header with token
- GraphQL queries validated server-side
- No sensitive data in client-side code

### PWA Security

- HTTPS required for service worker
- Content Security Policy (CSP) considerations
- Secure token storage

## Performance Considerations

### Optimization Strategies

1. **Code Splitting**: Route-based code splitting via React Router
2. **Lazy Loading**: Consider lazy loading for routes
3. **Memoization**: `React.memo` used on ApplicationCard
4. **Pagination**: Limits data fetched per request
5. **Debouncing**: Search input debounced (800ms)
6. **Service Worker Caching**: Reduces network requests

### Bundle Size

- Vite optimizes bundle size automatically
- Tree shaking removes unused code
- Production builds are minified

## Scalability Considerations

### Current Limitations

- No global state management (may need Redux/Zustand for complex state)
- No API response caching (consider React Query or SWR)
- Limited error boundaries (add more for better error handling)

### Future Improvements

1. **State Management**: Consider Redux Toolkit or Zustand for complex state
2. **Data Fetching**: Consider React Query for better caching and synchronization
3. **Error Boundaries**: Add error boundaries for better error handling
4. **Testing**: Add unit and integration tests
5. **Type Safety**: Consider migrating to TypeScript

## Deployment Architecture

### CI/CD Pipeline

```
GitHub Push → GitHub Actions
    ↓
Build Job
    ├── Install Dependencies
    ├── Build Application
    └── Create Artifact
    ↓
Deploy Job
    ├── Download Artifact
    ├── Authenticate to Azure
    └── Deploy to Azure Web App
```

### Azure Web App

- Static file hosting
- HTTPS enabled
- Environment variables configured
- Auto-deployment from main branch

## Monitoring and Logging

### Current Logging

- Console logs for debugging
- Error logging in catch blocks
- Service worker registration logs

### Recommended Additions

- Error tracking (Sentry, LogRocket)
- Analytics (Google Analytics, custom)
- Performance monitoring
- User behavior tracking

## Dependencies Architecture

### Core Dependencies

- **React**: UI framework
- **Vite**: Build tool and dev server
- **React Router**: Client-side routing
- **Keycloak JS**: Authentication

### UI Dependencies

- **Tailwind CSS**: Styling
- **Headless UI**: Accessible components
- **Heroicons**: Icons

### PWA Dependencies

- **Vite PWA Plugin**: PWA generation
- **Workbox**: Service worker and caching

### Development Dependencies

- **ESLint**: Code quality
- **TypeScript Types**: Type definitions

## File Organization Principles

1. **Feature-Based**: API files organized by feature/domain
2. **Component Co-location**: Related components in same directory
3. **Configuration Centralization**: All config in `config/` directory
4. **Separation of Concerns**: Clear boundaries between layers

## Best Practices Implemented

1. ✅ Functional components with hooks
2. ✅ Component memoization where appropriate
3. ✅ Centralized configuration
4. ✅ Reusable API helpers
5. ✅ Error handling in API layer
6. ✅ Responsive design
7. ✅ Accessibility considerations (Headless UI)
8. ✅ PWA best practices

## Areas for Improvement

1. ⚠️ Add TypeScript for type safety
2. ⚠️ Implement error boundaries
3. ⚠️ Add unit and integration tests
4. ⚠️ Consider state management library for complex state
5. ⚠️ Add API response caching layer
6. ⚠️ Implement proper loading states
7. ⚠️ Add analytics and error tracking
8. ⚠️ Improve token storage security (consider httpOnly cookies)

---

This architecture document provides a technical overview of the EXPA Mobile application. For user-facing documentation, see the main README.md file.

